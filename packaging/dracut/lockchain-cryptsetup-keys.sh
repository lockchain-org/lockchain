#!/bin/bash
# Generated by LockChain (LUKS) v{{VERSION}}
set -u
set -o pipefail
set -E

LABEL="{{TOKEN_LABEL}}"
MOUNTPOINT="{{MOUNTPOINT}}"
KEY_FILENAME="{{KEY_FILENAME}}"
KEY_SHA256="{{KEY_SHA256}}"
KEY_UUID="{{KEY_UUID}}"
MAPPINGS_STR="{{MAPPINGS}}"

DEST_DIR="/run/cryptsetup-keys.d"
MAX_WAIT_SECONDS=30
SOURCE_WAIT_SECONDS=90
SLEEP_INTERVAL=1
MOUNT_RETRIES=3
MOUNT_OPTS="ro,nosuid,nodev,noexec"

log_line() {
    echo "[LOCKCHAIN] $*" >&2
}

info() {
    log_line "INFO :: $*"
}

warn() {
    log_line "WARN :: $*"
}

fallback_exit() {
    if [[ $# -gt 0 ]]; then
        warn "$*"
    fi
    warn "LockChain defers to native/systemd passphrase prompts."
    exit 0
}

trap 'rc=$?; if (( rc != 0 )); then warn "LockChain cryptsetup key staging aborted (rc=${rc})."; warn "Deferring to native prompts."; trap - EXIT; exit 0; fi' EXIT

settle_udev() {
    if command -v udevadm >/dev/null 2>&1; then
        if ! udevadm settle >/dev/null 2>&1; then
            warn "udevadm settle reported an error; continuing regardless."
        fi
    fi
}

wait_for_device() {
    local elapsed=0
    while (( elapsed < MAX_WAIT_SECONDS )); do
        if blkid -L "$LABEL" >/dev/null 2>&1; then
            return 0
        fi
        sleep "$SLEEP_INTERVAL"
        ((elapsed += SLEEP_INTERVAL))
    done
    return 1
}

wait_for_source_key() {
    local path="$1"
    local elapsed=0
    while (( elapsed < SOURCE_WAIT_SECONDS )); do
        if [[ -f "$path" ]]; then
            return 0
        fi
        sleep "$SLEEP_INTERVAL"
        ((elapsed += SLEEP_INTERVAL))
    done
    return 1
}

mount_token() {
    local device="$1"
    mkdir -p "$MOUNTPOINT"
    if mountpoint -q "$MOUNTPOINT"; then
        return 0
    fi

    local attempt=0
    while (( attempt < MOUNT_RETRIES )); do
        if mount -o "$MOUNT_OPTS" "$device" "$MOUNTPOINT"; then
            return 0
        fi
        sleep "$SLEEP_INTERVAL"
        ((attempt += 1))
    done
    return 1
}

verify_uuid() {
    local device="$1"
    if [[ -z "${KEY_UUID// }" ]]; then
        return 0
    fi

    local actual
    if ! actual="$(blkid -s UUID -o value "$device" 2>/dev/null)"; then
        fallback_exit "Unable to read UUID for $device; refusing to use token."
    fi
    if [[ -z "$actual" ]]; then
        fallback_exit "Token $device reports empty UUID; refusing to use token."
    fi

    if [[ "${actual,,}" != "${KEY_UUID,,}" ]]; then
        fallback_exit "Token UUID mismatch for $device (expected ${KEY_UUID}, found ${actual})."
    fi
}

verify_size() {
    local path="$1"
    local size=0
    if command -v stat >/dev/null 2>&1; then
        size=$(stat -c '%s' "$path" 2>/dev/null || echo 0)
    else
        size=$(wc -c <"$path" 2>/dev/null || echo 0)
    fi
    if [[ "$size" != "32" ]]; then
        fallback_exit "Key file $path must be 32 raw bytes (found ${size})."
    fi
}

verify_checksum() {
    local path="$1"
    if [[ -z "${KEY_SHA256// }" ]]; then
        return 0
    fi

    local actual=""
    if actual="$(sha256sum "$path" 2>/dev/null)"; then
        set -- $actual
        actual="$1"
    else
        fallback_exit "Unable to compute SHA-256 for $path."
    fi

    if [[ "${actual,,}" != "${KEY_SHA256,,}" ]]; then
        fallback_exit "Checksum mismatch for $path (expected ${KEY_SHA256}, found ${actual})."
    fi
}

ensure_dest_writable() {
    local dir="$1"
    mkdir -p "$dir" 2>/dev/null || true
    chmod 700 "$dir" 2>/dev/null || true

    if touch "$dir/.rwtest" 2>/dev/null; then
        rm -f "$dir/.rwtest" 2>/dev/null || true
        return 0
    fi

    umount "$dir" 2>/dev/null || true
    if mount -t tmpfs -o rw,nosuid,nodev,mode=700 lockchain-cryptsetup-keys "$dir" 2>/dev/null; then
        if touch "$dir/.rwtest" 2>/dev/null; then
            rm -f "$dir/.rwtest" 2>/dev/null || true
            return 0
        fi
    fi

    local alt="/tmp/cryptsetup-keys"
    mkdir -p "$alt" 2>/dev/null || true
    chmod 700 "$alt" 2>/dev/null || true
    if ! mountpoint -q "$alt" 2>/dev/null; then
        mount -t tmpfs -o rw,nosuid,nodev,mode=700 lockchain-cryptsetup-keys-alt "$alt" 2>/dev/null || true
    fi

    rm -rf "$dir" 2>/dev/null || true
    if ln -s "$alt" "$dir" 2>/dev/null; then
        if touch "$dir/.rwtest" 2>/dev/null; then
            rm -f "$dir/.rwtest" 2>/dev/null || true
            return 0
        fi
    fi

    return 1
}

main() {
    if [[ -z "${MAPPINGS_STR// }" ]]; then
        info "No LockChain-managed crypt mappings configured; skipping staging."
        return 0
    fi

    IFS=' ' read -r -a MAPPINGS <<< "$MAPPINGS_STR"
    if (( ${#MAPPINGS[@]} == 0 )); then
        info "No LockChain-managed crypt mappings configured; skipping staging."
        return 0
    fi

    settle_udev

    if ! wait_for_device; then
        fallback_exit "Token label $LABEL not detected within ${MAX_WAIT_SECONDS}s."
    fi

    local device
    device="$(blkid -L "$LABEL" 2>/dev/null || true)"
    if [[ -z "${device// }" ]]; then
        fallback_exit "Token $LABEL not detected; skipping auto-unlock."
    fi

    verify_uuid "$device"

    if ! mount_token "$device"; then
        fallback_exit "Unable to mount token $device at $MOUNTPOINT."
    fi

    local source_key="$MOUNTPOINT/$KEY_FILENAME"
    if ! wait_for_source_key "$source_key"; then
        fallback_exit "Key file $source_key not detected within ${SOURCE_WAIT_SECONDS}s on token."
    fi

    verify_size "$source_key"
    verify_checksum "$source_key"

    if ! ensure_dest_writable "$DEST_DIR"; then
        fallback_exit "Unable to prepare staging directory $DEST_DIR."
    fi

    umask 077
    for mapping in "${MAPPINGS[@]}"; do
        if [[ -z "${mapping// }" ]]; then
            continue
        fi
        if [[ ! "$mapping" =~ ^[A-Za-z0-9_.-]+$ ]]; then
            warn "Skipping unsafe mapping name '$mapping' for key staging."
            continue
        fi
        local tmp="$DEST_DIR/.${mapping}.key.$$"
        local dest="$DEST_DIR/${mapping}.key"
        if ! cat "$source_key" >"$tmp" 2>/dev/null; then
            warn "Failed to stage key for $mapping."
            rm -f "$tmp" 2>/dev/null || true
            continue
        fi
        chmod 0400 "$tmp" 2>/dev/null || true
        mv -f "$tmp" "$dest" 2>/dev/null || {
            warn "Failed to promote staged key for $mapping."
            rm -f "$tmp" 2>/dev/null || true
            continue
        }
        chmod 0400 "$dest" 2>/dev/null || true
        info "Staged key for $mapping at $dest."
    done

    return 0
}

main "$@"
