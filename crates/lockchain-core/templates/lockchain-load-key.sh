#!/bin/bash
# Generated by lockchain-zfs v{{VERSION}}
set -euo pipefail
set -E

LABEL="{{TOKEN_LABEL}}"
MOUNTPOINT="{{MOUNTPOINT}}"
KEY_FILENAME="{{KEY_FILENAME}}"
KEY_PATH="{{KEY_PATH}}"
KEY_SHA256="{{KEY_SHA256}}"
KEY_UUID="{{KEY_UUID}}"
DATASETS_STR="{{DATASETS}}"
MAX_WAIT_SECONDS=30
SOURCE_WAIT_SECONDS=90
SLEEP_INTERVAL=1
MOUNT_RETRIES=3
MOUNT_OPTS="ro,nosuid,nodev,noexec"
ALT_STAGING="/tmp/lockchain"

log_line() {
    echo "[LOCKCHAIN] $*" >&2
}

info() {
    log_line "INFO :: $*"
}

warn() {
    log_line "WARN :: $*"
}

error() {
    log_line "ERROR :: $*"
}

fallback_exit() {
    if [[ $# -gt 0 ]]; then
        warn "$*"
    fi
    warn "LockChain auto-unlock defers to native/systemd passphrase prompts."
    exit 0
}

trap 'rc=$?; if (( rc != 0 )); then error "LockChain loader aborted (rc=${rc})."; fi' EXIT

wait_for_device() {
    local elapsed=0
    while (( elapsed < MAX_WAIT_SECONDS )); do
        if blkid -L "$LABEL" >/dev/null 2>&1; then
            return 0
        fi
        sleep "$SLEEP_INTERVAL"
        ((elapsed += SLEEP_INTERVAL))
    done
    return 1
}

wait_for_key() {
    local elapsed=0
    while (( elapsed < MAX_WAIT_SECONDS )); do
        if [[ -f "$KEY_PATH" ]]; then
            return 0
        fi
        sleep "$SLEEP_INTERVAL"
        ((elapsed += SLEEP_INTERVAL))
    done
    return 1
}

wait_for_source_key() {
    local path="$1"
    local elapsed=0
    while (( elapsed < SOURCE_WAIT_SECONDS )); do
        if [[ -f "$path" ]]; then
            return 0
        fi
        sleep "$SLEEP_INTERVAL"
        ((elapsed += SLEEP_INTERVAL))
    done
    return 1
}

wait_for_dataset() {
    local dataset="$1"
    local elapsed=0
    while (( elapsed < MAX_WAIT_SECONDS )); do
        if zfs list -H -o name "$dataset" >/dev/null 2>&1; then
            return 0
        fi
        sleep "$SLEEP_INTERVAL"
        ((elapsed += SLEEP_INTERVAL))
    done
    return 1
}

settle_udev() {
    if command -v udevadm >/dev/null 2>&1; then
        if ! udevadm settle >/dev/null 2>&1; then
            warn "udevadm settle reported an error; continuing regardless."
        fi
    fi
}

mount_token() {
    local device="$1"
    mkdir -p "$MOUNTPOINT"
    if mountpoint -q "$MOUNTPOINT"; then
        info "Token already mounted at $MOUNTPOINT."
        return 0
    fi

    local attempt=0
    while (( attempt < MOUNT_RETRIES )); do
        if mount -o "$MOUNT_OPTS" "$device" "$MOUNTPOINT"; then
            info "Mounted $device at $MOUNTPOINT with opts=$MOUNT_OPTS."
            return 0
        fi
        warn "Mount attempt $((attempt + 1)) on $device failed; retrying…"
        sleep "$SLEEP_INTERVAL"
        ((attempt += 1))
    done
    return 1
}

verify_checksum() {
    if [[ -z "${KEY_SHA256// }" ]]; then
        info "No checksum recorded; skipping checksum verification."
        return 0
    fi
    local expected="${KEY_SHA256,,}"

    local size
    size=$(stat -c '%s' "$KEY_PATH" 2>/dev/null || echo 0)
    if (( size != 32 )); then
        fallback_exit "Key file $KEY_PATH must be 32 raw bytes (found ${size}). Replay tuning/init to convert."
    fi

    local actual=""
    if actual="$(sha256sum "$KEY_PATH" | awk '{print $1}')"; then
        actual="${actual,,}"
    else
        fallback_exit "Unable to compute SHA-256 for $KEY_PATH."
    fi

    if [[ "$actual" != "$expected" ]]; then
        fallback_exit "Checksum mismatch for $KEY_PATH (expected $expected, found $actual)."
    fi
    info "Key checksum verified for $KEY_PATH."
}

verify_uuid() {
    if [[ -z "${KEY_UUID// }" ]]; then
        return 0
    fi

    local actual
    if ! actual="$(blkid -s UUID -o value "$1" 2>/dev/null)"; then
        fallback_exit "Unable to read UUID for $1; refusing to use token."
    fi
    if [[ -z "$actual" ]]; then
        fallback_exit "Token $1 reports empty UUID; refusing to use token."
    fi

    if [[ "${actual,,}" != "${KEY_UUID,,}" ]]; then
        fallback_exit "Token UUID mismatch for $1 (expected ${KEY_UUID}, found ${actual})."
    fi
    info "Token UUID ${actual} matched expected policy."
}

verify_size() {
    local path="$1"
    local size
    size=$(stat -c '%s' "$path" 2>/dev/null || echo 0)
    if (( size != 32 )); then
        fallback_exit "Key file $path must be 32 raw bytes (found ${size})."
    fi
}

ensure_dest_writable() {
    local dir="$1"
    mkdir -p "$dir"
    chmod 700 "$dir"

    if touch "$dir/.rwtest" 2>/dev/null; then
        rm -f "$dir/.rwtest"
        return 0
    fi

    info "Attempting to make $dir writable (tmpfs staging)."
    umount "$dir" 2>/dev/null || true
    if mount -t tmpfs -o rw,nosuid,nodev,mode=700 lockchain-tmp "$dir" 2>/dev/null; then
        if touch "$dir/.rwtest" 2>/dev/null; then
            rm -f "$dir/.rwtest"
            return 0
        fi
    fi

    if mountpoint -q "$dir"; then
        mount -o remount,rw "$dir" 2>/dev/null || true
        if touch "$dir/.rwtest" 2>/dev/null; then
            rm -f "$dir/.rwtest"
            return 0
        fi
    fi

    local alt="/tmp/lockchain"
    mkdir -p "$alt"
    chmod 700 "$alt"
    if ! mountpoint -q "$alt"; then
        mount -t tmpfs -o rw,nosuid,nodev,mode=700 lockchain-alt "$alt" 2>/dev/null || true
    fi
    if touch "$alt/.rwtest" 2>/dev/null; then
        rm -f "$alt/.rwtest"
        umount "$dir" 2>/dev/null || true
        if mount --bind "$alt" "$dir" 2>/dev/null; then
            if touch "$dir/.rwtest" 2>/dev/null; then
                rm -f "$dir/.rwtest"
                return 0
            fi
        fi
    fi

    # If still not writable, replace the directory with a symlink to the tmpfs.
    rm -rf "$dir" 2>/dev/null || true
    if ln -s "$alt" "$dir" 2>/dev/null; then
        if touch "$dir/.rwtest" 2>/dev/null; then
            rm -f "$dir/.rwtest"
            return 0
        fi
    fi

    return 1
}

resolve_encryption_root() {
    local dataset="$1"
    local root
    root=$(zfs get -H -o value encryptionroot "$dataset" 2>/dev/null || true)
    if [[ -z "$root" || "$root" == "-" ]]; then
        echo "$dataset"
    else
        echo "$root"
    fi
}

load_dataset_key() {
    local dataset="$1"
    local keyloc="$2"

    info "Invoking zfs load-key -L ${keyloc} ${dataset}."
    if zfs load-key -L "${keyloc}" "${dataset}"; then
        local rc=$?
        info "zfs load-key returned ${rc} for ${dataset}."
        return 0
    fi

    local rc=$?
    warn "zfs load-key -L ${keyloc} ${dataset} returned ${rc}; retrying with -r in case child datasets also need the key."
    if zfs load-key -r -L "${keyloc}" "${dataset}"; then
        rc=$?
        info "zfs load-key -r returned ${rc} for ${dataset}."
        return 0
    fi

    rc=$?
    fallback_exit "zfs load-key failed for ${dataset} (rc=${rc}); native prompts will take over."
}

main() {
    # Derive the mountpoint from the key path to avoid mismatches.
    # Avoid dirname dependency (not always present in early userspace).
    MOUNTPOINT="${KEY_PATH%/*}"
    if [[ -z "$MOUNTPOINT" || "$MOUNTPOINT" == "$KEY_PATH" ]]; then
        MOUNTPOINT="/run/lockchain"
    fi
    if [[ "$MOUNTPOINT" == "/run/lockchain/media" ]]; then
        MOUNTPOINT="${MOUNTPOINT}/${LABEL}"
        KEY_PATH="${MOUNTPOINT}/${KEY_FILENAME}"
    fi

    info "Awaiting token label $LABEL (timeout ${MAX_WAIT_SECONDS}s)…"
    if ! wait_for_device; then
        fallback_exit "Token $LABEL not detected within ${MAX_WAIT_SECONDS}s."
    fi

    settle_udev

    local device
    device="$(blkid -L "$LABEL" 2>/dev/null || true)"
    if [[ -z "$device" ]]; then
        fallback_exit "Token label $LABEL resolved earlier but vanished before mount."
    fi
    info "Token $LABEL detected at $device."

    verify_uuid "$device"

    if ! mount_token "$device"; then
        fallback_exit "Unable to mount $device at $MOUNTPOINT after ${MOUNT_RETRIES} attempts."
    fi

    local source_key="$MOUNTPOINT/$KEY_FILENAME"
    if ! wait_for_source_key "$source_key"; then
        fallback_exit "Key file $source_key not detected within ${SOURCE_WAIT_SECONDS}s on token."
    fi
    verify_size "$source_key"
    # Use the on-token key directly to avoid depending on writable /run during initramfs.
    KEY_PATH="$source_key"

    info "Waiting for key file $KEY_PATH (timeout ${MAX_WAIT_SECONDS}s)…"
    if ! wait_for_key; then
        fallback_exit "Key file $KEY_PATH not detected within ${MAX_WAIT_SECONDS}s."
    fi
    if command -v stat >/dev/null 2>&1; then
        info "Key file located: $(stat -c '%s bytes, mode %a' "$KEY_PATH")."
    else
        local bytes
        bytes=$(wc -c <"$KEY_PATH")
        info "Key file located: ${bytes} bytes (stat unavailable)."
    fi
    verify_size "$KEY_PATH"

    verify_checksum

    IFS=' ' read -r -a DATASETS <<< "$DATASETS_STR"
    if (( ${#DATASETS[@]} == 0 )) || [[ -z "${DATASETS_STR// }" ]]; then
        fallback_exit "No datasets configured for lockchain loader; cannot invoke zfs load-key."
    fi

    local keyloc="file://${KEY_PATH}"
    declare -A LOADED=()
    for dataset in "${DATASETS[@]}"; do
        if [[ -z "${dataset// }" ]]; then
            continue
        fi

        local target
        target=$(resolve_encryption_root "$dataset")
        if [[ -z "${target// }" ]]; then
            warn "Dataset ${dataset} has no encryptionroot; skipping."
            continue
        fi

        if [[ -n "${LOADED[$target]:-}" ]]; then
            info "Encryption root ${target} already processed; skipping duplicate."
            continue
        fi

        if ! wait_for_dataset "$target"; then
            warn "Dataset ${target} not visible after import; skipping load-key."
            continue
        fi

        load_dataset_key "$target" "$keyloc"
        LOADED[$target]=1
    done
}

main
